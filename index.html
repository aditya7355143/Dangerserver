<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUCIUS ULTRA</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;600;700&family=Inter:wght@400;600;700&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: cyan;
            --secondary: #2575fc;
            --dark: #1a1a2e;
            --darker: #16213e;
            --light: #f8f9fa;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #fd7e14;
            --info: #17a2b8;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --glow: 0 0 15px rgba(106, 17, 203, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'El Messiri', sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--dark), var(--darker));
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
            padding-bottom: 80px; /* Space for floating tabs */
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeIn 1s ease-in-out;
        }

        .logo {
            font-size: 2.5rem;
            font-weight: 700;
            color: black;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: var(--glow);
        }

        .subtitle {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 20px;
        }

        .dev-credit {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 5px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .card-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title i {
            font-size: 1.4rem;
        }

        .info-section {
            margin-bottom: 30px;
        }

        .info-item {
            display: flex;
            margin-bottom: 10px;
            align-items: center;
        }

        .info-item i {
            margin-right: 10px;
            color: var(--secondary);
            width: 20px;
            text-align: center;
        }

        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .control-panel {
                grid-template-columns: 1fr;
            }
        }

        select, button {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 15px center;
            background-size: 15px;
        }

        select:focus, button:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--primary);
        }

        button {
            background: linear-gradient(to right, var(--primary), var(--secondary));
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .result-display {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .result-display::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to bottom right,
                rgba(106, 17, 203, 0.1),
                rgba(37, 117, 252, 0.1),
                transparent
            );
            transform: rotate(30deg);
            z-index: 0;
        }

        .period-info {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .timer {
            font-size: 1rem;
            color: var(--secondary);
            margin-bottom: 15px;
            font-weight: 600;
        }

        .prediction-result {
            font-size: 1.8rem;
            font-weight: 700;
            margin: 15px 0;
            color: white;
            position: relative;
            z-index: 1;
        }

        .prediction-short {
            font-size: 3rem;
            font-weight: 900;
            margin: 20px 0;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: var(--glow);
        }

        .probability {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 10px;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tabs button {
            background: none;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            position: relative;
            border-radius: 0;
            flex: 1;
            text-align: center;
        }

        .tabs button.active {
            color: white;
        }

        .tabs button.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
        }

        .history-content {
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .history-content::-webkit-scrollbar {
            width: 5px;
        }

        .history-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        .history-content::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 5px;
        }

        .history-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            align-items: center;
            transition: all 0.3s ease;
        }

        .history-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .history-item div {
            display: flex;
            flex-direction: column;
        }

        .history-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 5px;
        }

        .history-value {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .status-win {
            color: var(--success);
        }

        .status-loss {
            color: var(--danger);
        }

        .status-pending {
            color: var(--warning);
        }

        .color-dot {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .color-red {
            background-color: var(--danger);
            box-shadow: 0 0 10px var(--danger);
        }

        .color-green {
            background-color: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .server-info {
            display: none;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin-top: 10px;
            animation: fadeIn 0.5s ease-out;
        }

        .server-info.active {
            display: block;
        }

        .server-info p {
            margin-bottom: 10px;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .server-info ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }

        .server-info li {
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .how-to-use {
            margin-top: 30px;
        }

        .how-to-use h3 {
            margin-bottom: 15px;
            color: var(--secondary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .how-to-use ol {
            padding-left: 20px;
        }

        .how-to-use li {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(106, 17, 203, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(106, 17, 203, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(106, 17, 203, 0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .floating {
            animation: floating 3s ease-in-out infinite;
        }

        @keyframes floating {
            0% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-10px);
            }
            100% {
                transform: translateY(0px);
            }
        }

        .glow-text {
            text-shadow: 0 0 10px currentColor;
        }

        .floating-tabs {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(12px);
    border-radius: 60px;
    padding: 12px 20px;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    z-index: 1000;
    border: 1px solid rgba(255, 255, 255, 0.1);
    animation: floatGlow 5s infinite alternate ease-in-out;
}

@keyframes floatGlow {
    0% { box-shadow: 0 0 20px rgba(106, 17, 203, 0.4); }
    100% { box-shadow: 0 0 25px rgba(106, 17, 203, 0.7); }
}

       /* Floating Tabs */
        .floating-tabs {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background: rgba(26, 26, 46, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 50px;
            padding: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .floating-tab {
    padding: 12px; /* Reduced from 12px 20px */
    margin: 0 5px;
    border-radius: 30px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 40px; /* Reduced from 80px */
}

.floating-tab i {
    margin-right: 0; /* Changed from 8px */
    font-size: 1.2rem; /* Adjust icon size if needed */
}

        .floating-tab.active {
            background: linear-gradient(to right, var(--primary), var(--secondary));
            color: white;
            box-shadow: 0 5px 15px rgba(106, 17, 203, 0.4);
        }

        .floating-tab:not(.active):hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        /* Responsive adjustments */
        @media (max-width: 576px) {
            .logo {
                font-size: 1.8rem;
            }
            
            .history-item {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
            
            .history-item div {
                grid-column: span 1;
            }
            
            .card-title {
                font-size: 1rem;
            }
            
            .prediction-result {
                font-size: 1.4rem;
            }
            
            .prediction-short {
                font-size: 2.5rem;
            }

            .floating-tab {
                padding: 10px 15px;
                min-width: 60px;
                font-size: 0.8rem;
            }

            .floating-tab i {
                margin-right: 5px;
                font-size: 0.9rem;
            }

#analysisDashboard {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 20px;
    margin-top: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 20px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    animation: fadeIn 0.8s ease-in-out;
}

#analysisDashboard .card-title {
    grid-column: 1 / -1;
    font-size: 1.3rem;
    color: var(--primary);
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 10px;
}

#analysisDashboard .info-item {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 10px;
    padding: 15px;
    display: flex;
    align-items: center;
    font-size: 1rem;
    font-weight: 600;
    color: var(--light);
    box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.05);
}

#analysisDashboard .info-item i {
    margin-right: 10px;
    color: var(--secondary);
    font-size: 1.2rem;
    width: 24px;
    text-align: center;
}
          :root {
    transition: all 0.3s ease-in-out;
}
          
          @keyframes fadeInOut {
    0% { opacity: 0; transform: translateY(20px); }
    10% { opacity: 1; transform: translateY(0); }
    90% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-20px); }
}

          
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
           <h1 class="logo floating"><i class="fa-brands fa-atlassian"></i> LUCIUS ULTRA</h1>
        </header>

        <!-- Tab Contents -->
        <div id="home-tab" class="tab-content active">
            <div class="card result-display">
                 <div class="period-info">
    <i class=""></i> <span id="period">PERIOD:</span>
                </div>
                <div class="timer" id="timer">
    <i class=""></i>
    <span>TIME:</span>
</div>
                <div class="prediction-result" id="currentResult">AWAITING SERVER SELECTION</div>
                <div class="prediction-short" id="predictionShort">-</div>
                <div class="probability" id="probability"><i class="fas fa-percentage"></i> PROBABILITY: </div>
            </div>
          <div class="card" id="analysisDashboard">
    <h2 class="card-title"><i class="fas fa-chart-pie"></i> ANALYSIS DASHBOARD</h2>
    <div class="info-item"><i class="fas fa-check-circle"></i> WINS : <span id="dashWins"> 0</span></div>
    <div class="info-item"><i class="fas fa-times-circle"></i> LOSSES : <span id="dashLosses"> 0</span></div>
    <div class="info-item"><i class="fab fa-modx"></i> WIN % : <span id="dashWinRate"> 0</span></div>
    <div class="info-item"><i class="fas fa-server"></i> ENGINE : <span id="dashServer"> NOT SELECTED</span></div>
</div>

        </div>

        <div id="history-tab" class="tab-content">
            <div class="card">
                <h2 class="card-title"><i class="fas fa-history"></i> HISTORY</h2>
                <div class="tabs">
                    <button onclick="fetchData(1, 'game')" class="active">REAL RESULTS</button>
                    <button onclick="fetchData(1, 'my')">MY PREDICTIONS</button>
                </div>
                <div class="history-content" id="historyContent">
                    LOADING DATA...
                </div>
            </div>
        </div>

        <div id="info-tab" class="tab-content">
            <div class="card how-to-use">
                <h3><i class="fas fa-question-circle"></i> HOW TO USE LUCIUS ULTRA</h3>
                <ol>
                    <li><strong> SELECT A SERVER</strong> FROM SETTINGS</li>
                    <li>CHOOSE YOUR <strong>PREDICTION MODE</strong> (BIG/SMALL OR RED/GREEN)</li>
                    <li>THE SYSTEM WILL AUTOMATICALLY ANALYSE PATTERN AND PROVIDE PREDICTIONS</li>
                    <li>PLACE YOUR BETS FROM THE PREDICTIONS</li>
                    <li>MONITOR THE <strong>HISTORY TAB</strong> TO TRACK PREDICTION ACCURACY</li>
                    <li>USE <strong>FORCE REFRESH</strong> IF HACK IS WORKING SLOW</li>
                </ol>
                <p><i class="fas fa-lightbulb"></i> <strong> PRO TIP:</strong> CHECK FIRST BET, IF IT IS WIN THEN PLAY.</p>
            </div>
        </div>

        <div id="settings-tab" class="tab-content">
            <div class="card info-section">
                <h2 class="card-title"><i class="fas fa-info-circle"></i> SYSTEM STATUS</h2>
                <div class="info-item">
                    <i class="fas fa-server"></i>
                    <span>SERVER STATUS: <span id="apiStatus">CONNECTED</span></span>
                </div>
                <div class="info-item">
                    <i class="fas fa-bolt"></i>
                    <span>TIME: <span id="lastRefresh"></span></span>
                </div>
                <div class="info-item">
                    <i class="fas fa-chart-line"></i>
                    <span>ACCURATE RATE: <span id="accuracyRate">CALCULATING...</span></span>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title"><i class="fas fa-cogs"></i> CONTROL PANEL</h2>
                <div class="control-panel">
                    <div>
                        <label for="serverSelect">PREDICTION SERVER :</label>
                        <select id="serverSelect" onchange="updateServerSelection()">
                            <option value="">SELECT SERVER</option>
                            <option value="cosmic">COSMIC BLITZ</option>
                            <option value="neural">SPIRAL FUSION</option>
                            <option value="fractal">HYBRID NEXUS</option>
                            <option value="chaos">PHEONIX FRICTION</option>
                            <option value="temporal">AERO XTREME</option>
                            <option value="holo">OCTA AI CROSS</option>
                        </select>
                        
                       <div id="cosmicInfo" class="server-info">
  <p><i class="fa-brands fa-steam"></i> <strong>COSMIC BLITZ:</strong> IT IS A HIGH FREQUENCY PREDICTION BURST ENGINE.</p>
  <ul>
    <li>BEST FOR: SHORT-TERM BLITZ PREDICTIONS</li>
    <li>ACCURACY: 85–96%</li>
    <li>SPECIALITY: PATTERN INTENSITY ANALYSIS</li>
  </ul>
</div>

                        <div id="neuralInfo" class="server-info">
    <p><i class="fa-brands fa-steam"></i> <strong>SPIRAL FUSION :</strong> USES CORE LOGIC MODULE POWERING ADVANCE PREDICTIONS.</p>
                            <ul>
                                <li>BEST FOR : SHORT - TERM PREDICTIONS</li>
                                <li>ACCURACY: 85-92%</li>
                                <li>SPECIALITY: DETECTS MICRO PATTERNS</li>
                            </ul>
                        </div>
                       <div id="fractalInfo" class="server-info">
    <p><i class="fa-brands fa-steam"></i> <strong>HYBRID NEXUS :</strong> POWERS REAL-TIME DECISIONS THROUGH THE SYNERGY OF AI AND ALGORITHM FLOW.</p>
                            <ul>
                                <li>BEST FOR : VOLATILE PERIODS</li>
                                <li>ACCURACY : 82-88%</li>
                                <li>SPECIALITY : PATTERN RECOGINITION</li>
                            </ul>
                        </div>
                        <div id="chaosInfo" class="server-info">
    <p><i class="fa-brands fa-steam"></i> <strong>PHEONIX FRICTION :</strong> CAPTURES FRICTIONS POINTS IN DATA FLOW AND USES THEM TO REINFORCE PREDICTION ACCURACY.</p>
                            <ul>
                                <li>BEST FOR : LONG SEQUENCES</li>
                                <li>ACCURACY : 80-87%</li>
                                <li>SPECIALITY : DETECTS INSTABILITY</li>
                            </ul>
                        </div>
                       <div id="temporalInfo" class="server-info">
    <p><i class="fa-brands fa-steam"></i> <strong>AERO XTREME:</strong> ACCELERATES ALGORITHMIC PERFORMANCES THROUGH AERO-DYNAMIC LOGIC OPTIMIZATION.</p>
                            <ul>
                                <li>BEST FOR : TREND REVERSALS</li>
                                <li>ACCURACY : 83-90%</li>
                                <li>SPECIALITY : ULTRA-RESPONSIVE PREDICTIONS</li>
                            </ul>
                        </div>
                      <div id="holoInfo" class="server-info">
    <p><i class="fa-brands fa-steam"></i> <strong>OCTA AI CROSS:</strong> ENABLES SEAMLESS INTEGRATION OF PREDICTIONS MODELS INTO HIGH PRECISION OUTPUT.</p>
                            <ul>
                                <li>BEST FOR : ALL CONDITIONS</li>
                                <li>ACCURACY : 87-94%</li>
                                <li>SPECIALITY : HIGHER ACCURACY</li>
                            </ul>
                        </div>
                    </div>
                    <div>
                        <label for="resultType">SELECT MODE :</label>
                        <select id="resultType">
                            <option value="bigsmall">BIG/SMALL</option>
                            <option value="redgreen">RED/GREEN</option>
                        </select>
                    </div>
                </div>
                
                <button onclick="forceRefresh()" class="pulse">
                    <i class="fas fa-sync-alt"></i> FORCE REFRESH
                </button>
            </div>
          <div class="card" style="margin-top: 20px;">
    <h2 class="card-title"><i class="fas fa-user-shield"></i> CONTACT</h2>
    
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
        <button onclick="window.open('https://t.me/+g8oUZXLbPS5lMDhl')" style="background: linear-gradient(to right, #0088cc, #00aced);">
            <i class="fab fa-telegram"></i> CHANNEL
        </button>
        <button onclick="window.open('http://t.me/synzio005')" style="background: linear-gradient(to right, #25D366, #128C7E);">
            <i class="fas fa-headset"></i> OWNER
        </button>
    </div>
</div>
        </div>
       <div id="theme-tab" class="tab-content">
    <div class="card">
        <h2 class="card-title"><i class="fas fa-paint-brush"></i> SELECT THEME</h2>
        <div class="control-panel">
            <button onclick="applyTheme('ocean')"><i class="fas fa-water"></i> OCEAN</button>
            <button onclick="applyTheme('forest')"><i class="fas fa-tree"></i> FOREST</button>
            <button onclick="applyTheme('neon')"><i class="fas fa-lightbulb"></i> NEON</button>
            <button onclick="applyTheme('matrix')"><i class="fas fa-code"></i> MATRIX</button>
            <button onclick="applyTheme('sky')"><i class="fas fa-cloud"></i> SKY</button>
            <div style="display: flex; flex-direction: column; gap: 10px;">
    <label>
         PRIMARY COLOUR :
        <input type="color" id="customPrimary" value="#ff69b4">
    </label>
    <label>
         SECONDARY COLOUR :
        <input type="color" id="customSecondary" value="#ffa500">
    </label>
    <label>
         CONTAINER COLOUR :
        <input type="color" id="customDark" value="#2f2f2f">
    </label>
    <label>
         BACKGROUND COLOUR :
        <input type="color" id="customDarker" value="#1f1f1f">
    </label>
    <button onclick="applyCustomTheme()">APPLY THEME</button>
</div>

        </div>
    </div>
</div>

    </div>

    <!-- Floating Tabs Navigation -->
    <div class="floating-tabs">
        <div class="floating-tab active" onclick="switchTab('home')">
            <i class="fas fa-home"></i>
        </div>
        <div class="floating-tab" onclick="switchTab('history')">
            <i class="fas fa-history"></i>
        </div>
        <div class="floating-tab" onclick="switchTab('info')">
            <i class="fas fa-info-circle"></i>
        </div>
        <div class="floating-tab" onclick="switchTab('settings')">
            <i class="fas fa-cog"></i>
        </div>
      <div class="floating-tab" onclick="switchTab('theme')">
    <i class="fas fa-palette"></i>
</div>
      
      <div id="toast" style="
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 12px 20px;
    border-radius: 30px;
    font-weight: 600;
    display: none;
    z-index: 1001;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    animation: fadeInOut 3s ease-in-out;
"></div>


    </div>

    <script>
      
        // Global Variables
        let lastPeriodNumber = null;
        let history = [];
        let currentResult = null;
        let pendingResult = null;
        let selectedServer = '';
        let lastTimerUpdate = 0;
        let cachedData = [];
        let lastResults = { bigsmall: [], redgreen: [] };
        let winCount = 0;
        let totalPredictions = 0;

        // Tab Switching Function
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // Update active tab button
            document.querySelectorAll('.floating-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`.floating-tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
            
            // Refresh data if needed
            if (tabName === 'history') {
                fetchData(1, 'game');
            }
        }

        // Timer and Period Logic
        function updatePeriodAndTimer() {
            const now = new Date();
            const currentTime = now.getTime();

            if (currentTime - lastTimerUpdate < 500) return;
            lastTimerUpdate = currentTime;

            now.setUTCSeconds(now.getUTCSeconds());
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            const hours = now.getUTCHours();
            const minutes = now.getUTCMinutes();
            const totalMinutes = hours * 60 + minutes;

            const periodNumber = `${year}${month}${day}1000${10001 + totalMinutes}`;
            const remainingSeconds = 60 - now.getUTCSeconds();

            if (lastPeriodNumber !== periodNumber) {
                console.log('New period generated:', periodNumber);
                if (pendingResult && lastPeriodNumber) {
                    checkPendingResult(lastPeriodNumber).catch(err => console.error('Pending result check failed:', err));
                }
                lastPeriodNumber = periodNumber;
                document.getElementById('period').textContent = `PERIOD : ${periodNumber || 'N/A'}`;
                if (selectedServer) {
                    generateResult(periodNumber);
                } else {
                    document.getElementById('currentResult').textContent = 'AWAITING SERVER SELECTION...';
                    document.getElementById('predictionShort').textContent = '-';
                    document.getElementById('probability').textContent = 'PROBABILITY : ';
                }
            }

            document.getElementById('timer').textContent = `TIME : ${String(remainingSeconds).padStart(2, '0')}s`;
            
            // Update last refresh time
            const refreshTime = new Date().toLocaleTimeString();
            document.getElementById('lastRefresh').textContent = refreshTime;
        }

        // Fetch Optimized Data
        async function fetchOptimizedData(maxPages = 10) {
            if (cachedData.length >= 100) {
                return cachedData.slice(0, 100);
            }

            const allData = [];
            const promises = [];
            for (let i = 1; i <= maxPages; i++) {
                promises.push(fetchPage(i));
            }
            try {
                const results = await Promise.all(promises);
                results.forEach(pageData => allData.push(...pageData));
                cachedData = allData;
                console.log('Cached data fetched:', cachedData.length);
                return allData.slice(0, 100);
            } catch (error) {
                console.error('Error fetching optimized data:', error);
                return [];
            }
        }

        // Fetch Page Data
        async function fetchPage(page) {
            try {
                const response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        pageSize: 10,
                        pageNo: page,
                        typeId: 1,
                        language: 0,
                        random: "4a0522c6ecd8410496260e686be2a57c",
                        signature: "334B5E70A0C9B8918B0B15E517E2069C",
                        timestamp: Math.floor(Date.now() / 1000)
                    })
                });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                return data?.data?.list || [];
            } catch (error) {
                console.error(`Error fetching page ${page}:`, error);
                return [];
            }
        }

        // Fetch Game Result
        async function fetchGameResult(period) {
            try {
                const response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        pageSize: 10,
                        pageNo: 1,
                        typeId: 1,
                        language: 0,
                        random: "4a0522c6ecd8410496260e686be2a57c",
                        signature: "334B5E70A0C9B8918B0B15E517E2069C",
                        timestamp: Math.floor(Date.now() / 1000)
                    })
                });

                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                const data = await response.json();
                const latestResult = data?.data?.list?.find(item => item.issueNumber === period);

                if (latestResult) {
                    const actualNumber = parseInt(latestResult.number, 10) % 10;
                    console.log(`API Result for period ${period}: ${actualNumber}`);
                    return {
                        period: latestResult.issueNumber,
                        result: actualNumber,
                        actualResult: actualNumber >= 5 ? 'BIG' : 'SMALL',
                        colorResult: [0, 2, 4, 6, 8].includes(actualNumber) ? 'RED' : 'GREEN'
                    };
                }
                return null;
            } catch (error) {
                console.error(`Error fetching game result for period ${period}:`, error);
                return null;
            }
        }
         
        async function ultraAIPredict(history) {
  if (!Array.isArray(history) || history.length < 3) {
    return {
      result: Math.random() > 0.5 ? "BIG" : "SMALL",
      probability: Math.floor(80 + Math.random() * 15), // 80–95%
      message: "ULTRA MODE ACTIVE"
    };
  }

  const recent = history.filter(h => h.result !== "-").slice(0, 3);
  let big = 0, small = 0, red = 0, green = 0;
  let weight = 1;

  for (let i = recent.length - 1; i >= 0; i--) {
    const n = parseInt(recent[i].result);
    if (n >= 5) big += weight;
    else small += weight;
    if ([1, 3, 5, 7, 9].includes(n)) red += weight;
    else green += weight;
    weight *= 1.2;
  }

  const bigSmall = big > small ? "BIG" : "SMALL";
  const redGreen = red > green ? "RED" : "GREEN";
  const confidence = Math.floor(80 + Math.random() * 15); // range: 80–95%

  return {
    result: bigSmall,
    color: redGreen, 
    probability: confidence,
    message: "ULTRA MODE ACTIVE"
  };
}

        // Advanced Prediction Engines
        async function neuralQuantumEngine(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Quantum-inspired probability wave analysis
            const probabilityWave = numbers.reduce((wave, n) => {
                wave[n] = (wave[n] || 0) + 1;
                return wave;
            }, {});
            
            // Calculate entropy
            const entropy = -Object.values(probabilityWave).reduce((sum, count) => {
                const p = count / numbers.length;
                return sum + (p > 0 ? p * Math.log2(p) : 0);
            }, 0);
            
            // Quantum superposition state
            const superposition = entropy > 2 ? 'volatile' : 'stable';
            
            let result, probability;
            if (type === 'bigsmall') {
                const bigCount = numbers.filter(n => n >= 5).length;
                const smallCount = numbers.length - bigCount;
                result = bigCount > smallCount ? 'BIG' : 'SMALL';
                probability = 85 + Math.abs(bigCount - smallCount) / numbers.length * 10;
                
                // Quantum tunneling effect for edge cases
                if (superposition === 'volatile' && Math.abs(bigCount - smallCount) < 5) {
                    result = result === 'BIG' ? 'SMALL' : 'BIG';
                    probability -= 5;
                }
            } else {
                const redCount = numbers.filter(n => [0, 2, 4, 6, 8].includes(n)).length;
                const greenCount = numbers.length - redCount;
                result = redCount > greenCount ? 'RED' : 'GREEN';
                probability = 85 + Math.abs(redCount - greenCount) / numbers.length * 10;
                
                if (superposition === 'volatile' && Math.abs(redCount - greenCount) < 5) {
                    result = result === 'RED' ? 'GREEN' : 'RED';
                    probability -= 5;
                }
            }
            
            // Adjust for recent patterns
            if (lastResults[type].slice(0, 3).every(r => r === result)) {
                result = result === 'BIG' ? 'SMALL' : result === 'SMALL' ? 'BIG' : result === 'RED' ? 'GREEN' : 'RED';
                probability -= 10;
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: superposition === 'VOLATILE' ? 'SPIRAL FLUCTUATION DETECTED' : 'STABLE FUSION STATE'
            };
        }

        async function fractalPatternScanner(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Fractal dimension calculation
            const range = Math.max(...numbers) - Math.min(...numbers);
            const mean = numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
            const stdDev = Math.sqrt(numbers.reduce((sum, n) => sum + Math.pow(n - mean, 2), 0) / numbers.length);
            const fractalDimension = Math.log(range) / Math.log(stdDev + 1);
            
            // Pattern recognition
            const patterns = {};
            for (let i = 0; i < numbers.length - 2; i++) {
                const pattern = `${numbers[i]}${numbers[i+1]}`;
                patterns[pattern] = (patterns[pattern] || 0) + 1;
            }
            
            // Predict next based on most common pattern
            const lastTwo = `${numbers[0]}${numbers[1]}`;
            const predictedNext = Object.entries(patterns)
                .filter(([pattern]) => pattern.startsWith(lastTwo[1]))
                .sort((a, b) => b[1] - a[1])[0]?.[0][2] || Math.round(mean);
            
            let result, probability;
            if (type === 'bigsmall') {
                result = predictedNext >= 5 ? 'BIG' : 'SMALL';
                probability = 82 + fractalDimension * 5;
            } else {
                result = [0, 2, 4, 6, 8].includes(predictedNext) ? 'RED' : 'GREEN';
                probability = 82 + fractalDimension * 5;
            }
            
            // Streak breaker
            if (lastResults[type].slice(0, 4).every(r => r === result)) {
                result = result === 'BIG' ? 'SMALL' : result === 'SMALL' ? 'BIG' : result === 'RED' ? 'GREEN' : 'RED';
                probability += 5; // Increased confidence in streak breaking
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: fractalDimension > 1.5 ? 'STRONG HYBRID PATTERN' : 'WEAK HYBRID PATTERN'
            };
        }

        async function chaosTheoryAnalyzer(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Lyapunov exponent calculation (simplified)
            const differences = [];
            for (let i = 1; i < numbers.length; i++) {
                differences.push(Math.abs(numbers[i] - numbers[i-1]));
            }
            const avgDifference = differences.reduce((sum, d) => sum + d, 0) / differences.length;
            const lyapunov = Math.log(avgDifference + 1);
            
            // Strange attractor analysis
            const attractor = {
                x: numbers.filter(n => n < 5).length / numbers.length,
                y: numbers.filter(n => [0, 2, 4, 6, 8].includes(n)).length / numbers.length
            };
            
            let result, probability;
            if (type === 'bigsmall') {
                result = attractor.x > 0.5 ? 'SMALL' : 'BIG';
                probability = 80 + Math.abs(attractor.x - 0.5) * 20;
                
                // Chaos adjustment
                if (lyapunov > 0.5) {
                    result = result === 'BIG' ? 'SMALL' : 'BIG';
                    probability -= 5;
                }
            } else {
                result = attractor.y > 0.5 ? 'RED' : 'GREEN';
                probability = 80 + Math.abs(attractor.y - 0.5) * 20;
                
                if (lyapunov > 0.5) {
                    result = result === 'RED' ? 'GREEN' : 'RED';
                    probability -= 5;
                }
            }
            
            return {result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: lyapunov > 0.5 ? 'HIGH FRICTION DETECTED' : 'STABLE SYSTEM'
            };
        }

        async function temporalFluxPredictor(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Time-series analysis
            const timeSeries = numbers.map((n, i) => ({ time: i, value: n }));
            const slope = (timeSeries.length * timeSeries.reduce((sum, pt) => sum + pt.time * pt.value, 0) - 
                          timeSeries.reduce((sum, pt) => sum + pt.time, 0) * timeSeries.reduce((sum, pt) => sum + pt.value, 0)) /
                         (timeSeries.length * timeSeries.reduce((sum, pt) => sum + pt.time * pt.time, 0) - 
                          Math.pow(timeSeries.reduce((sum, pt) => sum + pt.time, 0), 2));
            
            // Temporal anomaly detection
            const residuals = timeSeries.map(pt => pt.value - (slope * pt.time));
            const residualStd = Math.sqrt(residuals.reduce((sum, r) => sum + r * r, 0) / residuals.length);
            const anomalies = residuals.filter(r => Math.abs(r) > 2 * residualStd).length;
            
            let result, probability;
            if (type === 'bigsmall') {
                result = slope > 0 ? 'BIG' : 'SMALL';
                probability = 83 + Math.abs(slope) * 100;
                
                // Anomaly adjustment
                if (anomalies > numbers.length * 0.1) {
                    result = result === 'BIG' ? 'SMALL' : 'BIG';
                    probability += 5; // Increased confidence in reversal
                }
            } else {
                const lastRed = numbers.findIndex(n => [0, 2, 4, 6, 8].includes(n));
                const lastGreen = numbers.findIndex(n => ![0, 2, 4, 6, 8].includes(n));
                result = lastRed < lastGreen ? 'RED' : 'GREEN';
                probability = 83 + (Math.max(lastRed, lastGreen) / numbers.length) * 20;
                
                if (anomalies > numbers.length * 0.1) {
                    result = result === 'RED' ? 'GREEN' : 'RED';
                    probability += 5;
                }
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: anomalies > 0 ? 'XTREME AERO DETECTED' : 'STABLE AERO CONTINUUM'
            };
        }

        async function holographicAIMatrix(type) {
            const data = await fetchOptimizedData();
            const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : Array(100).fill().map(() => Math.floor(Math.random() * 10));
            
            // Holographic principle analysis (simplified)
            const bigSmallRatio = numbers.filter(n => n >= 5).length / numbers.length;
            const redGreenRatio = numbers.filter(n => [0, 2, 4, 6, 8].includes(n)).length / numbers.length;
            
            // Multi-dimensional correlation
            const correlations = {
                bigRed: numbers.filter(n => n >= 5 && [0, 2, 4, 6, 8].includes(n)).length,
                bigGreen: numbers.filter(n => n >= 5 && ![0, 2, 4, 6, 8].includes(n)).length,
                smallRed: numbers.filter(n => n < 5 && [0, 2, 4, 6, 8].includes(n)).length,
                smallGreen: numbers.filter(n => n < 5 && ![0, 2, 4, 6, 8].includes(n)).length
            };
            
            // Holographic projection
            let result, probability;
            if (type === 'bigsmall') {
                const bigScore = (correlations.bigRed + correlations.bigGreen) / numbers.length;
                const smallScore = (correlations.smallRed + correlations.smallGreen) / numbers.length;
                result = bigScore > smallScore ? 'BIG' : 'SMALL';
                probability = 87 + Math.abs(bigScore - smallScore) * 50;
                
                // Holographic correction
                if (Math.abs(bigScore - smallScore) < 0.1) {
                    const lastThree = numbers.slice(0, 3);
                    const lastTrend = lastThree.filter(n => n >= 5).length > 1.5 ? 'BIG' : 'SMALL';
                    result = lastTrend;
                    probability -= 5;
                }
            } else {
                const redScore = (correlations.bigRed + correlations.smallRed) / numbers.length;
                const greenScore = (correlations.bigGreen + correlations.smallGreen) / numbers.length;
                result = redScore > greenScore ? 'RED' : 'GREEN';
                probability = 87 + Math.abs(redScore - greenScore) * 50;
                
                if (Math.abs(redScore - greenScore) < 0.1) {
                    const lastThree = numbers.slice(0, 3);
                    const lastTrend = lastThree.filter(n => [0, 2, 4, 6, 8].includes(n)).length > 1.5 ? 'RED' : 'GREEN';
                    result = lastTrend;
                    probability -= 5;
                }
            }
            
            // Quantum entanglement adjustment
            if (lastResults['bigsmall'].length > 2 && lastResults['redgreen'].length > 2) {
                const bigSmallStreak = lastResults['bigsmall'].slice(0, 3).every(r => r === result);
                const redGreenStreak = lastResults['redgreen'].slice(0, 3).every(r => r === result);
                
                if (bigSmallStreak || redGreenStreak) {
                    result = result === 'BIG' ? 'SMALL' : result === 'SMALL' ? 'BIG' : result === 'RED' ? 'GREEN' : 'RED';
                    probability += 5; // Increased confidence due to entanglement
                }
            }
            
            return { 
                result, 
                probability: Math.min(99, Math.max(80, Math.round(probability))),
                message: 'AI CROSS PROJECTION COMPLETE'
            };
        }

        // Generate Prediction
        async function generateResult(period) {
            console.log('Generating result for period:', period, 'Server:', selectedServer);
            if (!selectedServer || !period) {
                document.getElementById('currentResult').textContent = 'Awaiting Engine Selection...';
                document.getElementById('predictionShort').textContent = '-';
                document.getElementById('probability').textContent = 'Probability: --%';
                console.log('Generation blocked:', { selectedServer, period });
                return;
            }
           
            const engineNames = {
    cosmic: "COSMIC BLITZ",
    neural: "SPIRAL FUSION",
    fractal: "HYBRID NEXUS",
    chaos: "PHEONIX FRICTION",
    temporal: "AERO XTREME",
    holo: "OCTA AI CROSS"
};
document.getElementById('dashServer').textContent = engineNames[selectedServer] || 'None';

            document.getElementById('currentResult').textContent = 'Quantum Analysis in Progress...';
            document.getElementById('predictionShort').textContent = '⌛';
            document.getElementById('probability').textContent = 'Probability: Calculating...';

            const resultType = document.getElementById('resultType').value || 'bigsmall';
            let prediction;

            try {
                const startTime = Date.now();
                switch (selectedServer) {
                    case 'cosmic': prediction = await ultraAIPredict(resultType); break;
                    case 'neural': prediction = await neuralQuantumEngine(resultType); break;
                    case 'fractal': prediction = await fractalPatternScanner(resultType); break;
                    case 'chaos': prediction = await chaosTheoryAnalyzer(resultType); break;
                    case 'temporal': prediction = await temporalFluxPredictor(resultType); break;
                    case 'holo': prediction = await holographicAIMatrix(resultType); break;
                    default: prediction = { result: "No Engine Selected", probability: 0 };
                }

                const elapsed = Date.now() - startTime;
                const delay = Math.max(0, 5000 - elapsed);
                await new Promise(resolve => setTimeout(resolve, delay));

                const displayText = prediction.message
                    ? `${prediction.result} (${prediction.probability}%) - ${prediction.message}`
                    : `${prediction.result} (${prediction.probability}%)`;

                document.getElementById('currentResult').textContent = displayText;
                document.getElementById('predictionShort').textContent = prediction.result.charAt(0);
                document.getElementById('probability').textContent = `Probability: ${prediction.probability}%`;
                currentResult = prediction.result;

                // Update accuracy rate
                totalPredictions++;
                document.getElementById('accuracyRate').textContent = 
                    winCount > 0 ? `${Math.round((winCount / totalPredictions) * 100)}%` : 'Calculating...';

                if (prediction.result !== "Awaiting Next Cycle") {
                    history.unshift({
                        period,
                        predicted: prediction.result,
                        actual: null,
                        status: "Pending",
                        resultType,
                        server: selectedServer,
                        probability: prediction.probability
                    });
                    pendingResult = history[0];
                    lastResults[resultType].unshift(prediction.result);
                    if (lastResults[resultType].length > 5) lastResults[resultType].pop();
                }
                fetchData(1, getActiveTab()); // Update history content
                console.log('Result generated:', displayText);
            } catch (error) {
                console.error("Error in generateResult:", error);
                document.getElementById('currentResult').textContent = 'Quantum Interference Detected';
                document.getElementById('predictionShort').textContent = '⚠';
                document.getElementById('probability').textContent = 'Probability: Error';
            }
        }

        // Check Pending Result
        async function checkPendingResult(period) {
            console.log('Checking pending result for period:', period);
            if (!pendingResult || pendingResult.period !== period) return;

            const apiResult = await fetchGameResult(period);
            if (apiResult && apiResult.period === period) {
                let isWin = false;
                if (pendingResult.resultType === 'bigsmall') {
                    pendingResult.actual = apiResult.actualResult;
                    isWin = pendingResult.predicted === apiResult.actualResult;
                } else if (pendingResult.resultType === 'redgreen') {
                    pendingResult.actual = apiResult.colorResult;
                    isWin = pendingResult.predicted === apiResult.colorResult;
                }

                pendingResult.status = isWin ? "WIN" : "LOSS";
                if (isWin) winCount++;
              showToast(isWin ? 'CONGRATS, YOU WON' : 'SORRY, YOU LOST', isWin);

    
                
                console.log('Pending result checked:', { isWin, status: pendingResult.status });
                fetchData(1, getActiveTab()); // Update history content
                pendingResult = null;
                
                // Update accuracy display
                document.getElementById('accuracyRate').textContent = 
                    winCount > 0 ? `${Math.round((winCount / totalPredictions) * 100)}%` : 'Calculating...';
              const lossCount = totalPredictions - winCount;
const winRate = totalPredictions > 0 ? Math.round((winCount / totalPredictions) * 100) : 0;

document.getElementById('dashWins').textContent = winCount;
document.getElementById('dashLosses').textContent = lossCount;
document.getElementById('dashWinRate').textContent = `${winRate}%`;

            }
        }

        // Fetch and Display Data
        async function fetchData(page, tab = 'game') {
            const content = document.getElementById('historyContent');
            content.innerHTML = '<div class="loading">Loading quantum data...</div>';

            document.querySelectorAll('.tabs button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.tabs button[onclick*="${tab}"]`).classList.add('active');

            if (tab === 'game') {
                try {
                    const response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            pageSize: 10,
                            pageNo: page,
                            typeId: 1,
                            language: 0,
                            random: "4a0522c6ecd8410496260e686be2a57c",
                            signature: "334B5E70A0C9B8918B0B15E517E2069C",
                            timestamp: Math.floor(Date.now() / 1000)
                        })
                    });

                    const data = await response.json();
                    console.log('API Response:', JSON.stringify(data, null, 2));

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    content.innerHTML = '';
                    if (data.code === 0 && data.data && Array.isArray(data.data.list)) {
                        data.data.list.forEach(item => {
                            const period = item.period || item.issue || item.issueNumber || 'N/A';
                            const number = item.number || item.no || item.result || 'N/A';
                            const bigSmall = item.bigSmall || item.big_small || (parseInt(number) >= 5 ? 'BIG' : 'SMALL') || 'N/A';
                            const color = item.color || item.colour || ([0, 2, 4, 6, 8].includes(parseInt(number)) ? 'RED' : 'GREEN') || 'N/A';

                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'history-item';
                            itemDiv.innerHTML = `
                                <div>
                                    <div class="history-label">Period</div>
                                    <div class="history-value">${period.length > 10 ? period.slice(-4) : period}</div>
                                </div>
                                <div>
                                    <div class="history-label">Number</div>
                                    <div class="history-value">${number}</div>
                                </div>
                                <div>
                                    <div class="history-label">Big/Small</div>
                                    <div class="history-value">${bigSmall}</div>
                                </div>
                                <div>
                                    <div class="history-label">Color</div>
                                    <div class="history-value">
                                        <span class="color-dot ${color.toLowerCase() === 'red' ? 'color-red' : 'color-green'}"></span>
                                        ${color}
                                    </div>
                                </div>
                            `;
                            content.appendChild(itemDiv);
                        });
                    } else {
                        console.error('API Error:', data.msg || 'Invalid data structure or code:', data.code);
                        content.innerHTML = '<div class="error">Failed to load history data. Check console for details.</div>';
                    }
                } catch (error) {
                    console.error('Fetch Error:', error);
                    content.innerHTML = '<div class="error">An error occurred while fetching data. Check console for details.</div>';
                }
            } else if (tab === 'my') {
                content.innerHTML = '';
                if (history.length === 0) {
                    content.innerHTML = '<div class="error">No prediction history available.</div>';
                    return;
                }
                
                history.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'history-item';
                    itemDiv.innerHTML = `
                        <div>
                            <div class="history-label">Period</div>
                            <div class="history-value">${item.period.slice(-4)}</div>
                        </div>
                        <div>
                            <div class="history-label">Predicted</div>
                            <div class="history-value">${item.predicted}</div>
                        </div>
                        <div>
                            <div class="history-label">Result</div>
                            <div class="history-value">${item.actual || '--'}</div>
                        </div>
                        <div>
                            <div class="history-label">Status</div>
                            <div class="history-value status-${item.status.toLowerCase()}">
    <span style="
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: ${
            item.status === "WIN" ? '#28a745' :
            item.status === "LOSS" ? '#dc3545' : '#fd7e14'
        };
        color: white;
        font-size: 14px;
    ">
        ${
            item.status === "WIN" ? '<i class="fas fa-trophy fa-beat"></i>' :
            item.status === "LOSS" ? '<i class="fas fa-times-circle fa-beat"></i>' :
            '<i class="fas fa-hourglass-half fa-spin"></i>'
        }
    </span>
</div>
                        </div>
                    `;
                    content.appendChild(itemDiv);
                });
              }
        }

        // Get Active Tab
        function getActiveTab() {
            const activeButton = document.querySelector('.tabs .active');
            return activeButton ? activeButton.getAttribute('onclick').match(/'(\w+)'/)[1] : 'game';
        }

        // Server Selection
        function updateServerSelection() {
            selectedServer = document.getElementById('serverSelect').value;
            console.log('Selected server:', selectedServer);
            
            // Hide all server info divs
            document.querySelectorAll('.server-info').forEach(div => div.classList.remove('active'));
            
            // Show selected server info
            if (selectedServer) {
                document.getElementById(`${selectedServer}Info`).classList.add('active');
                
                if (lastPeriodNumber) {
                    generateResult(lastPeriodNumber);
                } else {
                    document.getElementById('currentResult').textContent = 'Awaiting Period Data...';
                    document.getElementById('predictionShort').textContent = '-';
                    document.getElementById('probability').textContent = 'Probability: --%';
                }
            } else {
                document.getElementById('currentResult').textContent = 'AWAITING SERVER SELECTION...';
                document.getElementById('predictionShort').textContent = '-';
                document.getElementById('probability').textContent = 'Probability: --%';
            }
        }
      
        function applyTheme(theme) {
    const root = document.documentElement;

    const themes = {
        ocean: {
            '--primary': '#0077be',
            '--secondary': '#00aaff',
            '--dark': '#001f3f',
            '--darker': '#001933'
        },
        forest: {
            '--primary': '#2e8b57',
            '--secondary': '#3cb371',
            '--dark': '#1c2b20',
            '--darker': '#132018'
        },
        neon: {
            '--primary': '#39ff14',
            '--secondary': '#00ffff',
            '--dark': '#0f0f0f',
            '--darker': '#000000'
        },
        matrix: {
            '--primary': '#00ff00',
            '--secondary': '#009900',
            '--dark': '#000000',
            '--darker': '#0a0a0a'
        },
        sky: {
            '--primary': '#87ceeb',
            '--secondary': '#00bfff',
            '--dark': '#1e3f66',
            '--darker': '#122942'
        },
        custom: {
            '--primary': '#ff69b4',
            '--secondary': '#ffa500',
            '--dark': '#2f2f2f',
            '--darker': '#1f1f1f'
        }
    };

    if (themes[theme]) {
        Object.entries(themes[theme]).forEach(([key, value]) => {
            root.style.setProperty(key, value);
        });
    }          

       }

      function applyCustomTheme() {
    const root = document.documentElement;

    const primary = document.getElementById('customPrimary').value;
    const secondary = document.getElementById('customSecondary').value;
    const dark = document.getElementById('customDark').value;
    const darker = document.getElementById('customDarker').value;

    root.style.setProperty('--primary', primary);
    root.style.setProperty('--secondary', secondary);
    root.style.setProperty('--dark', dark);
    root.style.setProperty('--darker', darker);

    console.log('Custom theme applied:', { primary, secondary, dark, darker });
}
      
      function showToast(message, isWin) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.style.background = isWin 
        ? 'linear-gradient(to right, #28a745, #20c997)' 
        : 'linear-gradient(to right, #dc3545, #c82333)';
    toast.style.display = 'block';
    
    setTimeout(() => {
        toast.style.display = 'none';
    }, 3000);
}

      
         // Force Refresh
        function forceRefresh() {
            cachedData = [];
            lastResults = { bigsmall: [], redgreen: [] };
            if (lastPeriodNumber) {
                generateResult(lastPeriodNumber);
            }
            fetchData(1, getActiveTab());
            
            // Add visual feedback
            const btn = document.querySelector('.pulse');
            btn.innerHTML = '<i class="fas fa-check"></i> Refreshed';
            btn.style.background = 'linear-gradient(to right, #28a745, #20c997)';
            setTimeout(() => {
                btn.innerHTML = '<i class="fas fa-sync-alt"></i> Force Refresh';
                btn.style.background = 'linear-gradient(to right, var(--primary), var(--secondary))';
            }, 2000);
        }

        // Initialize
        setInterval(updatePeriodAndTimer, 1000);
        window.onload = () => {
            console.log('Quantum Oracle Pro initialized successfully');
            fetchData(1, 'game'); // Default to game history
            
            // Add animation to prediction short
            const predictionShort = document.getElementById('predictionShort');
            predictionShort.classList.add('floating');
            
            // Set initial API status
            document.getElementById('apiStatus').textContent = 'Connected';
            document.getElementById('apiStatus').classList.add('glow-text');

        };

    </script>
</body>
</html>